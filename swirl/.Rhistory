library(swirl)
swirl()
dim(pm0)
head(mp0)
head(pm0)
cnames
# [1] "# RD|Action Code|State Code|County Code|Site ID|Parameter|POC|Sample Duration|Unit|Method|Date|Start Time|Sample Value|Null Data Code|Sampling Frequency|Monitor Protocol (MP) ID|Qualifier - 1|Qualifier - 2|Qualifier - 3|Qualifier - 4|Qualifier - 5|Qualifier - 6|Qualifier - 7|Qualifier - 8|Qualifier - 9|Qualifier - 10|Alternate Method Detectable Limit|Uncertainty"
cnames <- strsplit(cnames, "|", fixed = TRUE)
cnames
# Nice, but we don't need all these. Assign to names(pm0) the output of a call to the function make.names with cnames[[1]][wcol] as the argument. The variable wcol holds the indices of the 5 columns we selected (from the 28) to use in this lesson, so those are the column names we'll need. As the name suggests, the function "makes syntactically valid names".
names(pm0) <- make.names(cnames[[1]][wcol])
head(mp0)
head(pm0)
x0 <- pm0$Sample.Value
str(x0)
mean(is.na(x0))
names(pm1) <- make.names(cnames[[1]][wcol])
dim(pm1)
x1 <- pm1$Sample.Value
mean(is.na(x1))
summary(x0)
summary(x1)
boxplot(x0, x1)
boxplot(log10(x0), log(x1))
boxplot(log10(x0), log10(x1))
negative <- x1 < 0
sum(negative, na.rm = TRUE)
mean(negative, na.rm = TRUE)
dates <- pm1$Date
str(dates)
dates <- as.Date(as.character(dates), "%Y%m%d")
head(dates)
q()
library(swirl)
swirl()
hist(dates[negative], "month")
swirl()
# Nice, but we don't need all these. Assign to names(pm0) the output of a call to the function make.names with cnames[[1]][wcol] as the argument. The variable wcol holds the indices of the 5 columns we selected (from the 28) to use in this lesson, so those are the column names we'll need. As the name suggests, the function "makes syntactically valid names".
names(pm0) <- make.names(cnames[[1]][wcol])
# Slides for this and other Data Science courses may be found at github https://github.com/DataScienceSpecialization/courses/. If you care to use them, they must be downloaded as a zip file and viewed locally. This lesson corresponds to 04_ExploratoryAnalysis/CaseStudy
# In this lesson we'll apply some of the techniques we learned in this course to study air pollution data, specifically particulate matter (we'll call it pm25 sometimes), collected by the U.S. Environmental Protection Agency. This website https://www.health.ny.gov/environmental/indoors/air/pmq_a.htm from New York State offers some basic information on this topic if you're interested.
# Particulate matter (less than 2.5 microns in diameter) is a fancy name for dust, and breathing in dust might pose health hazards to the population. We'll study data from two years, 1999 (when monitoring of particulate matter started) and 2012. Our goal is to see if there's been a noticeable decline in this type of air pollution between these two years.
# We've read in 2 large zipped files for you using the R command read.table (which is smart enough to unzip the files).  We stored the 1999 data in the array pm0 for you.
> dim(pm0)
dim(pm0)
head(pm0)
cnames
e
strsplit(cnames, "|", fixed = TRUE)
cnames
# [1] "# RD|Action Code|State Code|County Code|Site ID|Parameter|POC|Sample Duration|Unit|Method|Date|Start Time|Sample Value|Null Data Code|Sampling Frequency|Monitor Protocol (MP) ID|Qualifier - 1|Qualifier - 2|Qualifier - 3|Qualifier - 4|Qualifier - 5|Qualifier - 6|Qualifier - 7|Qualifier - 8|Qualifier - 9|Qualifier - 10|Alternate Method Detectable Limit|Uncertainty"
cnames <- strsplit(cnames, "|", fixed = TRUE)
# Nice, but we don't need all these. Assign to names(pm0) the output of a call to the function make.names with cnames[[1]][wcol] as the argument. The variable wcol holds the indices of the 5 columns we selected (from the 28) to use in this lesson, so those are the column names we'll need. As the name suggests, the function "makes syntactically valid names".
names(pm0) <- make.names(cnames[[1]][wcol])
head(pm0)
> x0 <- pm0$Sample.Value
x0 <- pm0$Sample.Value
str(x0)
names(pm1) <- make.names(cnames[[1]][wcol])
x1 <- pm1$Sample.Value
negative <- x1 < 0
dates <- pm1$Date
dates <- as.Date(as.character(dates), "%Y%m%d")
swirl()
cnames
# [1] "# RD|Action Code|State Code|County Code|Site ID|Parameter|POC|Sample Duration|Unit|Method|Date|Start Time|Sample Value|Null Data Code|Sampling Frequency|Monitor Protocol (MP) ID|Qualifier - 1|Qualifier - 2|Qualifier - 3|Qualifier - 4|Qualifier - 5|Qualifier - 6|Qualifier - 7|Qualifier - 8|Qualifier - 9|Qualifier - 10|Alternate Method Detectable Limit|Uncertainty"
cnames <- strsplit(cnames, "|", fixed = TRUE)
cnames
# Nice, but we don't need all these. Assign to names(pm0) the output of a call to the function make.names with cnames[[1]][wcol] as the argument. The variable wcol holds the indices of the 5 columns we selected (from the 28) to use in this lesson, so those are the column names we'll need. As the name suggests, the function "makes syntactically valid names".
names(pm0) <- make.names(cnames[[1]][wcol])
swirl()
swirl()
swirl()
dim(pm0)
head(pm0)
cnames
cnames <- strsplit(cnames, "|", fixed = TRUE)
cnames
head(pm0)
names(pm0) <- make.names(cnames[[1]][wcol])
head(pm0)
x0 <- pm0$Sample.Value
str(x0)
mean(is.na(x0))
names(pm1) <- make.names(cnames[[1]][wcol])
dim(pm1)
x1 <- pm1$Sample.Value
mean(is.na(x1))
summary(x0)
summary(x1)
boxplot(x0, x1)
oxplot(x0, x1)
boxplot(x0, x1)
boxplot(log10(x0), log10(x1))
negative <- x1 < 0
sum(negative, na.rm = TRUE)
mean(negative, na.rm = TRUE)
dates <- pm1$Date
str(dates)
dates <- as.Date(as.character(dates), "%Y%m%d")
head(dates)
hist(dates[negative], "month")
str(site0)
intersect(site0, site1)
both <- intersect(site0, site1)
both
head(pm0)
cnt0 <- subset(pm0, State.Code == 36 & contry.site %in% both)
cnt0 <- subset(pm0, State.Code == 36 & conty.site %in% both)
cnt0 <- subset(pm0, State.Code == 36 & county.site %in% both)
cnt1 <- subset(pm1, State.Code == 36 & county.site %in% both)
sapply(split(cnt0, cnt0$county.site), nrow)
sapply(split(cnt1, cnt1$county.site), nrow)
pm0sub <- subset(cnt0$County.Code == 63 & cnt0$Site.ID == 2008)
pm0sub <- subset(cnt0, County.Code == 63 & Site.ID == 2008)
pm1sub <- subset(cnt1, County.Code == 63 & Site.ID == 2008)
x0sub <- pm0sub$Sample.Value
x1sub <- pm1sub$Sample.Value
dates0 <- as.Date(as.character(pm0$Date), "%Y%m%d")
dates0 <- as.Date(as.character(pm0sub$Date), "%Y%m%d")
dates1 <- as.Date(as.character(pm1sub$Date), "%Y%m%d")
par(mfrow = c(1,2), mar = c(4,4,2,1))
plot(dates0, x0sub, pch = 20)
abline(h = median(x0sub, na.rm=TRUE), lwd = 2)
plot(dates1, x1sub, pch = 20)
abline(h = median(x1sub, na.rm=TRUE), lwd = 2)
rng <- range(x0sub, s1sub, na.rm = TRUE)
rng <- range(x0sub, x1sub, na.rm = TRUE)
rng
# Let's first gather the mean (average measurement) for each state in 1999. Recall that the original data for this year was stored in pm0.
mn0 <- with(pm0, tapply(Sample.Value, State.Code, mean, na.rm = TRUE))
str(mn0)
mn1 <- with(pm1, tapply(Sample.Value, State.Code, mean, na.rm = TRUE))
str(mn1)
summary(mn0)
summary(mn1)
d0 <- data.frame(state = names(mn0), mean = mn0)
d1 <- data.frame(state = names(mn1), mean = mn1)
merge(d0, d1, by = "state")
mrg <- merge(d0, d1, by = "state")
dim(mrg)
head(mrg)
with(mrg, plot(rep(1,52), mrg[,2], xlim = c(.5, 2.5)))
with(mrg, points(x = rep(2,52, y = mrg[,3])))
with(mrg, points(rep(2, 52), mrg[, 3]))
a
segments(with(mrg, points(rep(2, 52), mrg[, 3])))
with(mrg, segments(rep(1,52), mrg[,2], rep(2,52), mrg[,3]))
segments(rep(1, 52), mrg[, 2], rep(2, 52), mrg[, 3])
mrg[mrg$mean.x <- mrg$mean.y, ]
mrg[mrg$mean.x < mrg$mean.y, ]
q()
